#!/usr/bin/env python
"""
MalwareProxyX
Author Darsh Patel - darshkpatel@gmail.com
"""
try:
    from mitmproxy.options import Options
    from mitmproxy.proxy.config import ProxyConfig
    from mitmproxy.proxy.server import ProxyServer
    from mitmproxy.tools.dump import DumpMaster
    from mitmproxy import http
except ImportError:
    raise ImportError('mitmproxy isn\'t installed. You must install mitmproxy. Ideally run the setup scripts again')

import os
import logging
import sys
import subprocess
import tempfile

logger = logging.getLogger('MalwareProxyX')
logging.basicConfig(level=logging.INFO)


class MalwareProxyX:
    def __init__(self):
        self.logger = logger
        self.logger.info("Initializing MalwareProxyX")
        self.pre_run_checks()
        self.options = self.generate_options()

        self.master = ProxyMaster(self.options, with_termlog=False, with_dumper=False)
        self.master.server = ProxyServer(self.generate_config(self.options))
        self.master.addons.add(TrafficHandler())
        self.master.run()

    def pre_run_checks(self) -> None:
        self.logger.info("Running Pre Run Checks")
        if os.name == 'nt':
            self.logger.warning("Windows isn't currently supported")
            sys.exit(1)

        self.logger.info("Verifying IP Forwarding Support")
        try:
            if sys.platform == "darwin":
                if '0' in subprocess.check_output(["sysctl", "net.inet.ip.forwarding"], encoding="UTF-8").strip():
                    self.logger.warning(
                        "net.inet.ip.forwarding is not enabled \n Use: sysctl net.inet.ip.forwarding=1 to enable it")
                    sys.exit(1)
            elif sys.platform.startswith("linux"):
                if subprocess.check_output(["cat", "/proc/sys/net/ipv4/ip_forward"], encoding="UTF-8").strip() != "1":
                    self.logger.warning(
                        "ip forwarding is not enabled \n Use: echo 1 > /proc/sys/net/ipv4/ip_forward to enable it")
                    sys.exit(1)
        except Exception as e:
            self.logger.exception(e)
            sys.exit(1)

    def generate_options(self) -> Options:
        # ToDo: Add Support for Config File / ArgParser

        return Options(listen_host='0.0.0.0', listen_port=8080, http2=True, mode='regular')

    def generate_config(self, options: Options) -> ProxyConfig:
        # ToDo: Add Support for Config File / ArgParser

        config = ProxyConfig(options)
        return config


class TrafficHandler(object):
    def __init__(self):
        self.MaxRequestSize = 1000000
        self.logger = logger

    @staticmethod
    def request(flow: http.HTTPFlow):
        print(f'Processing Request: {flow.request.pretty_url}')

    def response(self, flow: http.HTTPFlow):
        patch_request = True

        if 'content-length' in flow.request.headers.keys():
            if int(flow.request.headers['content-length'][0]) >= self.MaxRequestSize:
                self.logger.warning(f"Not patching, Over Max Size Limit: {flow.request.pretty_url}")
                patch_request = False

        # ToDo: Check preconditions before processing
        if not patch_request:
            self.logger.warning(f"Not patching, didn't meet config preconditions: {flow.request.pretty_url}")
            return

        binary_format = self.check_binary_format(flow.reply.obj.response.content)
        if binary_format is not None:
            self.logger.info(f"FOUND: {binary_format} Binary, attempting to patch")

    @staticmethod
    def check_binary_format(_bytes) -> str:
        magic_bytes = {
            b'MZ': 'pe',
            b'7f454c46': 'elf',
            b'cafebabe': 'fatfile',
            b'cffaedfe': 'machox64',
        }
        if _bytes[0:2] in magic_bytes:
            return magic_bytes[_bytes[0:2]]
        elif _bytes[0:8] in magic_bytes:
            return magic_bytes[_bytes[0:8]]
        else:
            return None


class ProxyMaster(DumpMaster):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.logger = logger

    def run(self):
        try:
            self.logger.info("Starting Proxy. Press Ctrl+C to Stop")
            DumpMaster.run(self)
        except KeyboardInterrupt:
            self.logger.info("Stopping Proxy Server")
            self.shutdown()


if __name__ == "__main__":
    MalwareProxyX()
